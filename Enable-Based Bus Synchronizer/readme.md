# Enable-based Data Bus Synchronizer 

## Introducation 
![image](https://github.com/MahmouodMagdi/Clock-Domain-Crossing-Synchronizers/assets/72949261/692469f5-cf92-44e6-967a-0bd639765afa)

F0 represents a bank of flops which generates the bus that will cross the clock domain boundary. FE0 is another flop driven by the same clock – and it generates the enable signal – at the same time as the data is being generated by F0. This enable signal is synchronized through FE1 and FE2. Till the Enable signal does not reach the register bank F1 – the arrival of the data inputs on F1 does not matter. All clocks on F1 will be ignored – during this duration, due to lack of a valid enable. Hence, even if there is a setup/hold violation it does not matter.

By the time, enable passes through FE1 and FE2, it is expected that the data bus at the input of F1 register bank would have settled. At the next edge of clk2, the bank F1 will sample its data – which is all settled to its new value. So, F1 will sample the new value of the bus.


## Steps 
- One key idea in this design is that the synchronization event **(a pulse)** is converted into **a single toggle (either low to high, or high to low)** before being synchronized into the destination clock domain.

- Each toggle represents one event. **You need to be careful when resetting the synchronizer such that no unintended events are generated (i.e. if the source domain is reset on its own, and the toggle signal goes from high to low due to reset).**
  
- Source clock domain event to toggle generator. The following circuit resides in the **source clock domai**n, and **converts an event** that needs to traverse the clock domain crossing (CDC) into a **toggle**, which cannot be missed due to sampling in the destination clock domain.
  
![image](https://github.com/MahmouodMagdi/Clock-Domain-Crossing-Synchronizers/assets/72949261/a94dcb34-85c8-43d9-b1dc-31e1222e440f)


- Timing Diagram of the Toggle circuit
![image](https://github.com/MahmouodMagdi/Clock-Domain-Crossing-Synchronizers/assets/72949261/fe5b5279-e797-4da5-943e-2961347eaea5)


- Destination clock domain toggle to enable pulse generator

![image](https://github.com/MahmouodMagdi/Clock-Domain-Crossing-Synchronizers/assets/72949261/7d1edd2e-9be5-4c14-87ad-a09666ca7d71)


- Next, we need a circuit in the **destination clock domain** to **convert the toggle back into a pulse** to capture the multi-bit signal.

![image](https://github.com/MahmouodMagdi/Clock-Domain-Crossing-Synchronizers/assets/72949261/51dd8a59-3fb9-4175-a2a9-61a197cc7fd4)


- Finally, putting the entire synchronizer circuit together, we get the following
  
![image](https://github.com/MahmouodMagdi/Clock-Domain-Crossing-Synchronizers/assets/72949261/b793b804-ef50-43c9-9389-71743ae7ac4d)



***Notice*** the multi-bit data signal passes straight from source (clock) flip-flop to destination (clock) flip-flop to avoid problems with synchronizing multiple bits. A single control signal is synchronized to allow time for the multi-bit data to settle from possible metastable state. The load pulse from the source clock domain first gets converted into a toggle. The toggle is synchronized across the clock domain crossing (CDC), then gets converted back to a load pulse in the destination clock domain. Finally that load pulse is used to load the multi-bit data signal into flip-flops in the destination clock domain.

- The whole process takes **at least two destination clocks**.
- Therefore to use this circuit, you must be certain that **the input data only needs to be synchronized not more than once every three destination clock cycles**. If you are unsure, then a more advanced synchronization circuit like the handshake synchronization mechanism or FIFO-based synchronization.

## Cost of Enable Synchronization
For using an enable synchronization based method, **an additional enable signal has to be generated**. This would mean **additional circuitry** for generating this enable signal. This in turn would mean **additional area and power**. Further, **similar costs also get added for synchronizing this additional enable signal**. However, this cost is more than offset, because individual bits of the bus are no longer required to be synchronized individually. 
So, we can save on one synchronizing flop per bit. And, since we are talking about vectored signals, so, there has to be multiple bits. That means, the savings are in terms of multiple flops. However, once the bussed signal is generated, it takes 3 triggering edges of the destination clock for the values to be sampled.

- On the first edge, the enable signal goes past FE1.
- On the second edge, the enable signal goes past FE2.
- And on the third edge, the bussed signal actually gets captured on the destination side register bank.

Contrast this with the double flop synchronizer, There, the data reaches the destination flop at the second triggering edge of the destination flop. So, Enable Synchronization scheme has an **additional latency**.

But, that’s the price that you have to pay – in order to **avoid the risk of capturing garbage data**.

## Simualtion Results

![enable_based_sync_tb_1](https://github.com/MahmouodMagdi/Clock-Domain-Crossing-Synchronizers/assets/72949261/195fd677-853a-4593-8838-a1f187fdd3df)

![enable_based_sync_tb_2](https://github.com/MahmouodMagdi/Clock-Domain-Crossing-Synchronizers/assets/72949261/ad8bcde4-2416-4f05-9989-3e5f8c9452c8)


